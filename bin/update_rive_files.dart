import 'dart:io';
import 'dart:math';

/// Script to update the clientFiles map in rive_assets.dart
/// and assets section in pubspec.yaml based on actual .riv files
/// organized by client folders in assets/rive
///
/// Usage:
///   dart run bin/update_rive_files.dart [regenerateAllPasswords]
///
/// Arguments:
///   regenerateAllPasswords - Optional boolean flag (true/false)
///                           If true, regenerates all client passwords
///                           If false (default), preserves existing passwords
void main(List<String> args) async {
  // Parse arguments
  final regenerateAllPasswords =
      args.isNotEmpty && args[0].toLowerCase() == 'true';

  const assetsDir = 'assets/rive';
  const assetsFile = 'lib/utils/rive_assets.dart';
  const pubspecFile = 'pubspec.yaml';

  // Check if assets directory exists
  final assetsDirEntity = Directory(assetsDir);
  if (!await assetsDirEntity.exists()) {
    print('Error: Directory $assetsDir does not exist');
    exit(1);
  }

  // Check if assets file exists
  final assetsFileEntity = File(assetsFile);
  if (!await assetsFileEntity.exists()) {
    print('Error: File $assetsFile does not exist');
    exit(1);
  }

  // Check if pubspec file exists
  final pubspecFileEntity = File(pubspecFile);
  if (!await pubspecFileEntity.exists()) {
    print('Error: File $pubspecFile does not exist');
    exit(1);
  }

  print('Scanning for client folders and .riv files in $assetsDir...');

  // Map to store client name -> list of rive files
  final Map<String, List<String>> clientFiles = {};

  // Scan for client directories
  await for (final entity in assetsDirEntity.list()) {
    if (entity is Directory) {
      final clientName = entity.path.split('/').last;
      final rivFiles = <String>[];

      // Find all .riv files in this client's directory
      await for (final file in entity.list()) {
        if (file is File && file.path.endsWith('.riv')) {
          final fileName = file.path.split('/').last;
          rivFiles.add(fileName);
        }
      }

      // Sort the files alphabetically
      rivFiles.sort();

      if (rivFiles.isNotEmpty) {
        clientFiles[clientName] = rivFiles;
      }
    }
  }

  // Sort clients alphabetically
  final sortedClients = clientFiles.keys.toList()..sort();

  // Read existing passwords from rive_assets.dart
  final existingContent = await assetsFileEntity.readAsString();
  final Map<String, String> existingPasswords = _extractExistingPasswords(
    existingContent,
  );

  // Generate or preserve passwords for each client
  final Map<String, String> clientPasswords = {};
  final random = Random.secure();

  for (final client in sortedClients) {
    if (regenerateAllPasswords || !existingPasswords.containsKey(client)) {
      // Generate new password
      clientPasswords[client] = _generatePassword(random);
    } else {
      // Preserve existing password
      clientPasswords[client] = existingPasswords[client]!;
    }
  }

  if (regenerateAllPasswords) {
    print('ðŸ”„ Regenerating passwords for all clients...');
  } else {
    print(
      'ðŸ”’ Preserving existing passwords, generating for new clients only...',
    );
  }

  // Build the new clientFiles map declaration
  final buffer = StringBuffer();
  buffer.writeln('  static const Map<String, List<String>> _clientFiles = {');

  if (sortedClients.isEmpty) {
    buffer.writeln(
      '    // No client folders with .riv files found in assets/rive',
    );
  } else {
    for (final client in sortedClients) {
      final files = clientFiles[client]!;
      buffer.writeln("    '$client': [");
      for (final file in files) {
        buffer.writeln("      '$file',");
      }
      buffer.writeln('    ],');
    }
  }

  buffer.write('  };');

  // Build the clientPasswords map declaration
  final passwordsBuffer = StringBuffer();
  passwordsBuffer.writeln(
    '  static const Map<String, String> _clientPasswords = {',
  );

  if (sortedClients.isEmpty) {
    passwordsBuffer.writeln('    // Generated by bin/update_rive_files.dart');
  } else {
    for (final client in sortedClients) {
      passwordsBuffer.writeln("    '$client': '${clientPasswords[client]}',");
    }
  }

  passwordsBuffer.write('  };');

  // Read the current file content
  final content = await assetsFileEntity.readAsString();

  // Replace the clientFiles declaration using RegExp
  final pattern = RegExp(
    r'  static const Map<String, List<String>> _clientFiles = \{[\s\S]*?\};',
    multiLine: true,
  );

  var newContent = content.replaceFirst(pattern, buffer.toString());

  // Replace the clientPasswords declaration using RegExp
  final passwordsPattern = RegExp(
    r'  static const Map<String, String> _clientPasswords = \{[\s\S]*?\};',
    multiLine: true,
  );

  newContent = newContent.replaceFirst(
    passwordsPattern,
    passwordsBuffer.toString(),
  );

  // Write the updated content back to the file
  await assetsFileEntity.writeAsString(newContent);

  print('âœ… Successfully updated $assetsFile');

  // Update pubspec.yaml assets section
  final pubspecContent = await pubspecFileEntity.readAsString();

  // Build the new assets declaration
  final assetsBuffer = StringBuffer();
  assetsBuffer.writeln('  assets:');

  if (sortedClients.isEmpty) {
    assetsBuffer.writeln('    # No client folders found in assets/rive');
  } else {
    for (final client in sortedClients) {
      assetsBuffer.writeln('    - assets/rive/$client/');
    }
  }

  // Replace the assets declaration using RegExp
  final assetsPattern = RegExp(
    r'  assets:[\s\S]*?(?=\n\n|\nflutter:|\Z)',
    multiLine: true,
  );

  final newPubspecContent = pubspecContent.replaceFirst(
    assetsPattern,
    assetsBuffer.toString(),
  );

  // Write the updated content back to pubspec.yaml
  await pubspecFileEntity.writeAsString(newPubspecContent);

  print('âœ… Successfully updated $pubspecFile');
  print('Found ${sortedClients.length} client(s):');
  for (final client in sortedClients) {
    final files = clientFiles[client]!;
    final passwordStatus =
        existingPasswords.containsKey(client) && !regenerateAllPasswords
        ? '(preserved)'
        : '(new)';
    print(
      '  $client: ${files.length} file(s), password: ${clientPasswords[client]} $passwordStatus',
    );
    for (final file in files) {
      print('    - $file');
    }
  }
}

/// Extract existing passwords from rive_assets.dart content
Map<String, String> _extractExistingPasswords(String content) {
  final Map<String, String> passwords = {};

  // Match the _clientPasswords map content
  final pattern = RegExp(r"'([^']+)':\s*'([^']+)'", multiLine: true);

  final matches = pattern.allMatches(content);
  for (final match in matches) {
    // Check if this match is within the _clientPasswords section
    final matchStart = match.start;
    final passwordsMapStart = content.indexOf('_clientPasswords');
    final passwordsMapEnd = content.indexOf('};', passwordsMapStart);

    if (passwordsMapStart != -1 &&
        matchStart > passwordsMapStart &&
        matchStart < passwordsMapEnd) {
      final clientName = match.group(1)!;
      final password = match.group(2)!;
      passwords[clientName] = password;
    }
  }

  return passwords;
}

/// Generate a random password with 16-30 characters
String _generatePassword(Random random) {
  const chars =
      'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#\$%^&*()-_=+[]{}|;:,.<>?';
  final length = 16 + random.nextInt(15); // Random length between 16-30
  return List.generate(
    length,
    (index) => chars[random.nextInt(chars.length)],
  ).join();
}
